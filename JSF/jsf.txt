http://blog.yuriytkach.com/2009/11/javaserver-faces.html

12:42 - lit

UI component
-Renderer
-Validator
-Converter - переводить з строки в дату(напр.)
-Backing bean - моделька даних
-Events, Listeners
-Messages - ≥нфо при вал≥дац≥њ(напр.)
-navigation  - правила нав≥г. по стор≥нках (’ћЋ-ка)

<navigation-case>

.......
<redirect/>
</navigation-case>

======================================================
To overcome this problem, JSF 2.0 provides a flash object that can be populated
in one request and used in the next.

ExternalContext.getFlash().put("message", "Your password is about to expire");

#{flash.message}

You can even keep a value in the flash for more than one request. The
expression
#{flash.keep.message}

***************
<f:metadata>
<f:viewParam name="item" value="#{catalog.currentItem}"/>
</f:metadata>

*************************************
h:commandButton and h:commandLink generate POST requests.)
<h:button value="Done" outcome="done"/>
****************
Often, you will want to include parameters with a GET request link.
*The outcome string
Х View parameters
Х Nested f:param tags

<h:link outcome="index?q=1" value="Skip">
<h:link outcome="index?q=1&amp;score=0" value="Skip">
<h:link outcome="index" includeViewParams="true" value="Skip">

You can use the f:param tag to override view parameters. For example:
<h:link outcome="index" includeViewParams="true" value="Skip">
<f:param name="q" value="#{quizBean.currentProblem + 1}"/>
</h:link>

<h:commandLink action="index?faces-redirect=true&amp;includeViewParams=true"
value="Skip"/>
***************************************

NAvigation

<navigation-case>
<from-outcome>previous</from-outcome>
<if>#{quizBean.currentQuestion != 0}</if>
<to-view-id>/main.xhtml</to-view-id>
</navigation-case>

--------------

<navigation-case>
<from-action>#{quizBean.answerAction}</from-action>
<from-outcome>again</from-outcome>
<to-view-id>/again.xhtml</to-view-id>
</navigation-case>


<navigation-case>
<from-action>#{quizBean.startOverAction}</from-action>
<from-outcome>again</from-outcome>
<to-view-id>/index.xhtml</to-view-id>
</navigation-case>

<navigation-rule>
<from-view-id>/secure/*</from-view-id>
<navigation-case>
. . .
</navigation-case>
</navigation-rule>

----------<h>---------------
outputLink -  Link to another web site
commandButton -   Button: submit, reset, or pushbutton
commandLink -  Link that acts like a pushbutton
link - Link for issuing a GET request
-----------------------------
Params:
rendered
binding - Links this component with a backing
bean property

value

valueChangeListener - A method expression to a method that
responds to value changes

converter

validator

required

converterMessage,
validatorMessage,
requiredMessage

------------------
Binding

<h:inputText id="name" .../>
<h:message for="name"/>

For example, you could access the name component in a listener like this:
UIComponent component = event.getComponent().findComponent("name");

<h:inputText binding="#{form.nameField}" .../>

private UIComponent nameField = new UIInput();
public UIComponent getNameField() { return nameField; }
public void setNameField(UIComponent newValue) { nameField = newValue; }

---------------------------

===========================
CSS JS

<h:outputStylesheet library="css" name="styles.css"/>
<h:outputScript name="jsf.js" library="javascript" target="head" />
<h:graphicImage name="logo.png" library="images"/>

========================
Locale

<h:commandLink action="#{localeChanger.englishAction}">
<h:graphicImage library="images" name="en_flag.gif" style="border: 0px" />
</h:commandLink>

public class LocaleChanger {
...
public String englishAction() {
FacesContext context = FacesContext.getCurrentInstance();
context.getViewRoot().setLocale(Locale.ENGLISH);
return null;
}
}
-------------------------

errorClass CSS class applied to error messages.
errorStyle CSS style applied to error messages.
fatalClass CSS class applied to fatal messages.
fatalStyle CSS style applied to fatal messages

--------------------------
h:dataTable
Models:
*ArrayDataModel

Х ListDataModel
Х ResultDataModel
Х ResultSetDataModel
Х ScalarDataModel


public class TableData implements Serializable {
private static final Name[] names = new Name[] {
new Name("William", "Dupont"),
new Name("Anna", "Keeney"),
new Name("Mariko", "Randor"),
new Name("John", "Wilson")
};
private DataModel<Name> model = new ArrayDataModel<Name>(names);
public DataModel<Name> getNames() { return model; }
}
=====================================
Converter
<h:outputText value="#{payment.date}" converter="javax.faces.DateTime"/>
This is equivalent to using f:convertDateTime with no attributes:
<h:outputText value="#{payment.date}">
<f:convertDateTime/>
</h:outputText>
A third way of specifying the converter would be as follows:
<h:outputText value="#{payment.date}">
<f:converter converterId="

All JSF implementations must define a set of converters with predefined IDs:
Х javax.faces.DateTime (used by f:convertDateTime)
Х javax.faces.Number (used by f:convertNumber)
Table 7Ц2 Attributes of the f:convertDateTime Tag
Attribute Type Value
type String date (default), time, or both
dateStyle String default, short, medium, long, or full
timeStyle String default, short, medium, long, or full
pattern String Formatting pattern, as defined in
java.text.SimpleDateFormat
locale java.util.Locale or
String
Locale whose preferences are to be
used for parsing and formatting
timeZone java.util.TimeZone Time zone to use for parsing and
formatting; if you do not supply a
time zone, the default is GMT
Note: As of JSF 2.0, you can change
the default to TimeZone.getDefault() by
setting javax.faces.DATETIMECONVERTER
_DEFAULT_TIMEZONE_IS_SYSTEM_TIMEZONE
to true in web.xml.
Using Standard Converters 253
Х javax.faces.Boolean, javax.faces.Byte, javax.faces.Character, javax.faces.Double,
javax.faces.Float, javax.faces.Integer, javax.faces.Long, javax.faces.Short (automatically
used for primitive types and their wrapper classes)
Х javax.faces.BigDecimal, javax.faces.BigInteger (automatically used for
BigDecimal/BigInteger)

Err Msgs
<h:inputText id="amount" label="#{msgs.amount}" value="#{payment.amount}"/>
<h:message for="amount"/>
<h:message for="amount" showSummary="true" showDetail="false"/>





































